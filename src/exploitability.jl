function approx_exploitability(sol::POMCPSolver, cfr_sol::CFR.AbstractCFRSolver, n=sol.tree_queries, game=cfr_sol.game, p=2; use_tree_value=true)
    pomdp = POMDP(cfr_sol, game, p)
    policy = solve(sol, pomdp)
    action(policy, initialstate(pomdp))
    tree = policy._tree
    V_exploit = use_tree_value ? maximum(tree.v[first(tree.children)]) : tree_value(tree)
    return V_exploit - approx_eval(cfr_sol, n, game, p)
end

function approx_exploitability(cfr_sol::CFR.AbstractCFRSolver, n::Int, game::CFR.Game=cfr_sol.game, p::Int=2; kwargs...)
    sol = POMCPSolver(tree_queries=n, estimate_value=BestResponsePOMDP.RandomRollout())
    return approx_exploitability(sol, cfr_sol, n, game, p; kwargs...)
end

function approx_eval(sol, n, game, p)
    s = 0.0
    h0 = CFR.initialhist(game)
    for i ∈ 1:n
        s += _approx_eval(sol, game, p, h0)
    end
    return s / n
end

function _approx_eval(sol, game, p, h)
    game = sol.game
    if CFR.isterminal(game, h)
        return CFR.utility(game, p, h)
    elseif iszero(CFR.player(game, h))
        a = rand(CFR.chance_actions(game, h))
        return _approx_eval(sol, game, p, CFR.next_hist(game, h, a))
    else
        A = CFR.actions(game, h)
        I = CFR.infokey(game, h)
        σ = CFR.strategy(sol, I)
        a = A[CFR.weighted_sample(σ)]
        return _approx_eval(sol, game, p, CFR.next_hist(game, h, a))
    end
end

struct MaximizingTraverser
    b_children::Vector{Vector{Int}}
    a_children::Dict{Int, Vector{Int}}
    total_n::Vector{Int}
    v::Vector{Float64}
end

MaximizingTraverser(tree::BasicPOMCP.POMCPTree) = MaximizingTraverser(tree.children, a_children(tree), tree.total_n, tree.v)

# TODO: not necessary for games, but for actual POMDPs could weight values by visits
function a_children(tree::BasicPOMCP.POMCPTree)
    d = Dict{Int, Vector{Int}}()
    for (k,b_idx) in tree.o_lookup
        a_idx, o = k
        children = get!(d, a_idx) do
            Int[]
        end
        push!(children, b_idx)
    end
    return d
end

function tree_value(tree::BasicPOMCP.POMCPTree)
    d = a_children(tree)
    traverser = MaximizingTraverser(tree)
    return belief_value(traverser, 1)
end

function belief_value(tree::MaximizingTraverser, b_idx::Int)
    max_val = -Inf
    for a_idx ∈ tree.b_children[b_idx]
        val = action_value(tree, a_idx)
        if val > max_val
            max_val = val
        end
    end
    return max_val
end

function action_value(tree::MaximizingTraverser, a_idx::Int)
    children = get(tree.a_children, a_idx, nothing)
    isnothing(children) && return 0.0
    if isone(length(children)) && iszero(tree.total_n[only(children)])
        return tree.v[a_idx]
    end
    visit_sum = sum(tree.total_n[b_idx] for b_idx in children)
    s = 0.0
    if !iszero(visit_sum)
        for b_idx ∈ children
            s += (tree.total_n[b_idx]/visit_sum)*belief_value(tree, b_idx)
        end
    else
        s = tree.v[a_idx]
    end
    return s 
end
